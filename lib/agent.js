var Emitter = require('events').EventEmitter ;
var net = require('net') ;
var merge = require('merge') ;
var Request = require('./request') ;
var Response = require('./response') ;
var uuid = require('node-uuid') ;
var SipMessage = require('drachtio-sip').SipMessage ;
var debug = require('debug')('drachtio:client');
var logger = require('./logger') ;
var curry = require('curry') ;
var methods = require('./methods') ;
var util = require('util') ;

module.exports = exports = Agent ;

var CR = '\r' ;
var CRLF = '\r\n' ;

var defer = typeof setImmediate === 'function' ? setImmediate : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)); } ;

function Agent( cb ){
	if (!(this instanceof Agent)) return new Agent(cb);

	if( typeof cb !== 'function' ) throw new Error('Agent constructor requires a message callback function') ;

	Emitter.call(this); 

	this.cb = cb ;
	this.connected = false ;
	this.authenticated = false ;
	this.incomingMsg = '' ;
	this.verbs = {} ;

	//any request message awaiting a response from the server
	this.pendingRequests = {} ;

	//any sip request generated by us awaiting a final response from the server
	this.pendingSipRequests = {} ;

	this.apiLogger = function(){} ;

	this.__defineGetter__('idle', function() {
		var pendingCount = Object.keys(this.pendingRequests).length ;
		var pendingSipCount = Object.keys(this.pendingSipRequests).length ;
		if( pendingCount > 0 ) {
			console.log('count of pending requests: %d', pendingCount) ;
			console.log(util.inspect(this.pendingRequests)) ;
		}
		if( pendingSipCount > 0 ) {
			console.log('count of pending sip requests: %d', pendingSipCount) ;
			console.log(util.inspect(this.pendingSipRequests)) ;
		}

		return pendingCount + pendingSipCount === 0 ;
	}) ;

}
util.inherits(Agent, Emitter) ;

Agent.prototype.connect = function( opts, cb ) {
	if( typeof opts !== 'object' ) throw new Error('Agent#connect called with invalid args') ;

	debug('agent.connect, opts: ', opts ) ;
	var self = this ;

	merge( this, opts ) ;
	this.port = this.port || 9022 ;
	this.host = this.host || 'localhost' ;
	this.methods = this.methods || [] ;

	if( -1 !== this.methods.indexOf('*') ) {
		this.methods = methods ;
	}
	this.methods.forEach( function(method){
		try {
			self.route(method) ;
		} catch( e ) {
			debug('duplicate route entry: ', method) ;
		}
	}) ;

	this.socket = net.connect({
		port: this.port,
		host: this.host
	}, cb ) ;
	this.socket.setEncoding('utf8') ;

	this.socket.on('error', onError.bind(this.socket, this) ) ;
	this.socket.on('connect', onConnect.bind(this.socket, this) ) ;
	this.socket.on('data', onData.bind( this.socket, this) ) ;
	this.socket.on('close', onClose.bind( this.socket, this ) ) ;
} ;
Agent.prototype.disconnect = function( cb ) {
	if( !this.socket ) throw new Error('socket is not connected') ;
	debug('Agent#disconnect from %s', this.host + ':' + this.port) ;
	this.socket.end() ;
} ;
Agent.prototype.route = function( verb ) {
	if( verb in this.verbs ) throw new Error('duplicate route request for ' + verb) ;
	this.verbs[verb] = {
		sent: false
	} ;
	if( !this.authenticated ) return ;
	
	routeVerbs(this) ;
} ;
Agent.prototype.sendResponse = function( res, opts, callback ) {
	var self = this ;
	var msgId = sendMessage( this, res.msg, merge( {stackTxnId: res.req.stackTxnId}, opts) ) ;
	if( callback ) {
		this.pendingRequests[msgId] = function(token, msg, meta) {
			delete self.pendingRequests[msgId] ;
			if( 'OK' !== token[0] ) return callback(token[1]) ;
			res.meta = meta ;
			callback(null, new SipMessage(msg) ) ;
		} ;
	}
	if( res.status >= 200 ) defer( function() { res.emit('finish'); });
} ;

Agent.prototype.sendAck = function( method, dialogId, req, res, opts, callback ) {
	var m = new SipMessage() ;
	m.method = method ;
	m.uri = req.uri ;
	opts = opts || {} ;

	merge( opts, {stackDialogId: dialogId}) ;

	var msgId = sendMessage( this, m, opts ) ;
	if( callback ) {
		this.pendingRequests[msgId] = function(token, msg, meta) {
			if( 'OK' !== token[0] ) return callback(token[1]) ;			
			callback(null, new SipMessage(msg) ) ;
		} ;
	}
} ;

Agent.prototype.proxy = function( opts, callback ) {
	var msg = 'proxy|' + opts.stackTxnId + '|' + opts.type + '|' + opts.destinations[0] ;

	var cb = proxy( opts, callback ) ;

	var msgId = send( agent, msg ) ;
	this.pendingRequests[msgId] = cb ;
} ;

Agent.prototype.set = function(prop, val) {
	switch( prop ) {

		case 'api logger':
			this.apiLogger = logger(val) ;
			break ;
		case 'handler':
			this.cb = val ;
			break ;

		default:
			console.error('unsupported \'set\' property: ' + prop);
			break ;
	}
} ;

// uac features
Agent.prototype.uac = Agent.prototype.request = function(request_uri, options, callback) {
	var params = normalizeParams(request_uri, options, callback) ;
	return makeRequest( this, params ) ;
} ;

//private
var handle = function( agent, msg ) {
	var pos = msg.indexOf(CR) ;
	var leader = -1 == pos ? msg : msg.slice(0,pos) ;
	var token = leader.split('|') ;
	var res ;
	var sr ;
	var rawMsg ;

	switch( token[1] ) {
	case 'sip':
		rawMsg = msg.slice( pos+2 ) ;
		var sipMsg = new SipMessage( rawMsg ) ;
		var source = token[2] ;
		var numBytes = token[3] ;
		var protocol = token[4] ;
		var address = token[5] ;
		var port = token[6] ;
		var time = token[7] ;
		var transactionId = token[8] ;
		var dialogId = token[9] ;
		var meta = {
			source: source,
			address: address,
			port: port,
			protocol: protocol,
			time: time,
			transactionId: transactionId,
			dialogId: dialogId
		} ;
		if( token.length > 9 )

		if( 'network' === source && sipMsg.type === 'request' ) {
			var req = new Request( sipMsg, meta) ;
			res = new Response() ;
			req.res = res ;
			res.req = req ;
			req.agent = res.agent = agent ;

			debug('calling handler') ;
			agent.cb( req, res ) ;
		}
		else if( 'network' === source ) {
			if( transactionId in agent.pendingSipRequests ) {
				sr = agent.pendingSipRequests[transactionId] ;
				res = new Response(agent) ;
				res.msg = sipMsg ;
				res.meta = meta ;
				res.req = sr.req ;

				if( res.status >= 200 ) {
					delete agent.pendingSipRequests[transactionId]  ;
				}

				//prepare a function to be called for prack or ack, if appropriate
				var ack ;
				if( res.status >= 200 && res.req.method === 'INVITE') {
					ack = Response.prototype.sendAck.bind( res, token[9]) ;
				}
				else if( res.status > 100 && res.status < 200 ) {
					var require = res.req.get('Require');
					if( require && -1 !== require.value.indexOf('100rel')) {
						ack = Response.prototype.sendPrack.bind( res, token[9]) ;
					}
				}
				sr.req.emit('response', res, ack ) ;										
			}
		}
		break ;

	case 'response':
		var rId = token[2] ;
		if( rId in agent.pendingRequests ) {
			if( -1 !== pos ) rawMsg = msg.slice(pos+2) ;
			var meta2 = {
				source: token[4],
				address: token[7],
				port: token[8],
				protocol: token[6],
				time: token[9],
				transactionId: token[10],
				dialogId: token[11]
			} ;

			agent.pendingRequests[rId]( token.slice(3), rawMsg, meta2 ) ;
			delete agent.pendingRequests[rId] ;
		}
		break ;

	default:
		throw new Error('unexpected message with type: ' + token[1]) ;		
	}
} ;

var onClose = function(agent) {
	agent.connected = false ;
	Emitter.prototype.emit.call( agent, 'close' ) ;
} ;

var onConnect = function(agent) {
	 var msgId = send(agent, 'authenticate|' + agent.secret ) ;
	 agent.pendingRequests[msgId] = function(response) {
	 	agent.authenticated = ('OK' === response[0]) ;
		if( agent.authenticated ) {
			Emitter.prototype.emit.call( agent, 'connect', {
				hostport: response[1]
			}) ;
			debug('sucessfully authenticated, hostport is ', response[1]) ;
			routeVerbs(agent) ;
		}
	 } ;
} ;

var onError = function(agent, err) {
	Emitter.prototype.emit.call( agent, 'error', err ) ;
} ;

var onData = function(agent, msg) {
	agent.apiLogger( '<===' + CRLF + msg + CRLF) ;

	while( msg.length > 0 ) {
		if( 0 === agent.incomingMsg.length ) {
			//waiting for a new message
			var pos = msg.indexOf('#') ;
			if( -1 === pos || isNaN( agent.incomingMsgLength = parseInt( msg.slice(0, pos) ) ) )  throw new Error('invalid message from server, did not start with length#: ' + msg) ;
			var start = pos+1 ;
			var end = start + agent.incomingMsgLength ;
			agent.incomingMsg = msg.slice(start, end) ;
			msg = msg.length === (end + 1) ? '' : msg.slice(pos+1+ agent.incomingMsgLength) ;
		}
		else {
			//got a fragment last time
			var remainderSize = agent.incomingMsgLength - agent.incomingMsg.length ;
			agent.incomingMsg += msg.slice(0, remainderSize) ;
			msg = msg.slice(remainderSize) ;
		}

		//if we've got a full message, process it
		if( agent.incomingMsg.length === agent.incomingMsgLength ) {
			handle( agent, agent.incomingMsg ) ;
			agent.incomingMsg = '' ;
		}
	}
} ;

var sendMessage = function( agent, msg, opts ) {
	var m = msg ;

	if( opts && (opts.headers || opts.body ) ) {
		m = new SipMessage( msg ) ;
		for( var hdr in (opts.headers || {}) ) { 
			m.set(hdr, opts.headers[hdr]) ; 
		}
		if( opts.body ) m.body = opts.body ;
	}

	var s = 'sip|' ;
	if( opts && opts.stackTxnId ) {
		s += opts.stackTxnId ;
	}
	s += '|' ;
	if( opts && opts.stackDialogId ) {
		s += opts.stackDialogId ;
	}
	s += CRLF + m.toString() ;

	return send( agent, s ) ;	
} ;

var send = function( agent, msg ) {
	var msgId = uuid.v1() ;
	var s = msgId + '|' + msg ;
	agent.socket.write( s.length + '#' + s ) ;
	agent.apiLogger( '===>' + CRLF + s.length + '#' + s + CRLF) ;
	return msgId ;
} ;

var routeVerbs = function(agent) {
	for( var verb in agent.verbs ) {
		if( agent.verbs[verb].sent ) continue ;

		agent.verbs[verb].sent = true ;
		agent.verbs[verb].acknowledged = false ;
		agent.verbs[verb].rid = send(agent, 'route|' + verb) ;
	}
} ;

var normalizeParams  = function(uri, options, callback) {
	
	if (typeof uri === 'undefined' ) {
		var err = new Error('undefined is not a valid request_uri or options object.') ;
		console.error( err.stack ) ;
		throw err ;
	}

	// uac( request_uri, options, callback, ..)
	if (options && typeof options === 'object' ) {
		options.uri = uri ;
	} 
	// uac( request_uri, callback, ..)
	else if (typeof uri === 'string') {
		options = {uri:uri } ;
	}
	// uac( option, callback, ..) 
	else {
		callback = options ;
		options = uri ;
		uri = options.uri; 
	}

	options.method = options.method.toUpperCase() ;

	return { uri: uri, options: options, callback: callback || function(err, req, res){} } ;
} ;

var makeRequest = function( agent, params ) {

	//allow for requests within a dialog, where caller does not need to supply a uri
	if( !params.options.uri && !!params.options.stackDialogId ) {
		params.options.uri = 'sip:placeholder' ;
	} 

	var m = new SipMessage(params.options) ;

	//new outgoing request 
	var msg = 'sip|' ;
	if( params.options.stackTxnId ) {
		msg += params.options.stackTxnId ;
	}
	msg += '|' ;
	if( params.options.stackDialogId ) {
		msg += params.options.stackDialogId ;
	}

	var msgId = send(agent, msg + CRLF + m.toString() ) ;
	agent.pendingRequests[msgId] = function(token, msg) {
		if( token[0] === 'OK') {
			var transactionId = token[7] ;
			var meta = {
				source: token[1],
				address: token[4],
				port: token[5],
				protocol: token[3],
				time: token[6],
				transactionId: transactionId
			} ;

			var req = new Request( new SipMessage( msg ), meta ) ;
			req.agent = agent ;

			//Note: unfortunately, sofia (the nta layer) does not pass up the 200 OK response to a CANCEL
			//so we are unable to route it up to the application.
			//Therefore, we can't allocate this callback since it would never be called or freed
			if( params.options.method !== 'CANCEL') {
				agent.pendingSipRequests[transactionId] = {
					req: req
				} ;				
			}

			params.callback( null, req ) ;

		}
		else {
			params.callback(token[1] || 'request failed') ;
		}
	} ;
} ;

var proxy = function( opts, callback ) {
	var results = {} ;
	opts.destination.forEach( opts.destination, function( dest ){
		result[dest] = {
			status: 0,
			reason: '',
			timestamp: ''
		} ;
	}) ;

	return function( tokens ) {
		debug('TODO: proxy response handler, tokens: ', tokens) ;

		callback('not implemented') ;
	} ;
} ;